import { handleCORS } from "../../../lib/api-helpers.js";
import { protect } from "../../../lib/auth.js";
import { requireStudentRole } from "../../../middleware/portfolio-access.js";
import {
  createPortfolio,
  slugExists,
  findPortfolioBySlug,
} from "../../../lib/portfolio-helper.js";
import {
  validatePortfolioData,
  validateSlug,
} from "../../../lib/validation.js";

/**
 * @swagger
 * /api/portfolio:
 *   post:
 *     summary: Create a new portfolio
 *     tags: [Portfolio]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - slug
 *             properties:
 *               slug:
 *                 type: string
 *               layout:
 *                 type: string
 *                 enum: [single-page, multi-page]
 *               theme:
 *                 type: object
 *               sections:
 *                 type: array
 *               isPublic:
 *                 type: boolean
 *     responses:
 *       201:
 *         description: Portfolio created successfully
 *       400:
 *         description: Bad request
 *       401:
 *         description: Unauthorized
 */
export default async function handler(req, res) {
  // Handle CORS preflight
  if (handleCORS(req, res)) return;

  // Set cache-control headers
  res.setHeader(
    "Cache-Control",
    "no-store, no-cache, must-revalidate, private"
  );
  res.setHeader("Pragma", "no-cache");
  res.setHeader("Expires", "0");

  if (req.method !== "POST") {
    return res.status(405).json({
      success: false,
      message: "Method not allowed",
    });
  }

  try {
    // Check authentication
    const authResult = await protect(req);
    if (authResult.error) {
      return res.status(authResult.status).json({
        success: false,
        message: authResult.error,
      });
    }

    const user = authResult.user;

    // Check if user is a student
    if (user.role !== "student") {
      return res.status(403).json({
        success: false,
        message: "Only students can create portfolios",
      });
    }

    // Check if request body exists
    if (!req.body || typeof req.body !== "object") {
      console.error("Invalid request body:", req.body);
      return res.status(400).json({
        success: false,
        message: "Request body is required and must be a valid JSON object",
      });
    }

    const portfolioData = req.body;

    // Validate portfolio data
    const validation = validatePortfolioData(portfolioData, false);
    if (!validation.valid) {
      console.error("Portfolio validation failed:", validation.errors);
      return res.status(400).json({
        success: false,
        message: "Validation failed",
        errors: validation.errors,
      });
    }

    // Check if slug already exists
    const slugValidation = validateSlug(portfolioData.slug);
    if (!slugValidation.valid) {
      console.error("Slug validation failed:", slugValidation.error);
      return res.status(400).json({
        success: false,
        message: slugValidation.error,
      });
    }

    // Check if slug already exists and handle it
    let finalSlug = slugValidation.slug;
    let slugWasAutoGenerated = false;
    
    const slugAlreadyExists = await slugExists(finalSlug);
    if (slugAlreadyExists) {
      // Check if the existing portfolio belongs to this user
      const existingPortfolio = await findPortfolioBySlug(finalSlug);
      let studentIdStr = null;
      if (existingPortfolio) {
        if (
          typeof existingPortfolio.studentId === "object" &&
          existingPortfolio.studentId !== null
        ) {
          studentIdStr = existingPortfolio.studentId._id || existingPortfolio.studentId;
        } else {
          studentIdStr = existingPortfolio.studentId;
        }
      }
      
      const isOwnPortfolio =
        studentIdStr && user._id && String(studentIdStr) === String(user._id);
      
      if (isOwnPortfolio) {
        // User already owns this portfolio - suggest updating instead
        return res.status(400).json({
          success: false,
          message: `You already have a portfolio with this slug. Use PUT /api/portfolio/${existingPortfolio._id} to update it instead.`,
          existingPortfolioId: existingPortfolio._id,
          code: "SLUG_EXISTS_OWN",
        });
      } else {
        // Slug belongs to someone else - auto-generate a unique one
        let attempts = 0;
        const maxAttempts = 10;
        
        while (await slugExists(finalSlug) && attempts < maxAttempts) {
          // Generate a unique slug by appending a short random string
          const randomSuffix = Math.random().toString(36).substring(2, 6); // 4 random alphanumeric chars
          const candidateSlug = `${slugValidation.slug}-${randomSuffix}`;
          
          // Validate the new slug
          const candidateValidation = validateSlug(candidateSlug);
          if (candidateValidation.valid) {
            finalSlug = candidateValidation.slug;
            slugWasAutoGenerated = true;
          }
          attempts++;
        }
        
        if (attempts >= maxAttempts && await slugExists(finalSlug)) {
          // Fallback: use timestamp
          const timestampSuffix = Date.now().toString().slice(-6);
          const fallbackSlug = `${slugValidation.slug}-${timestampSuffix}`;
          const fallbackValidation = validateSlug(fallbackSlug);
          if (fallbackValidation.valid) {
            finalSlug = fallbackValidation.slug;
            slugWasAutoGenerated = true;
          } else {
            // Last resort: return error with suggestions
            return res.status(400).json({
              success: false,
              message: "This slug is already taken and we couldn't generate a unique alternative. Please choose a different slug.",
              code: "SLUG_EXISTS_OTHER",
              suggestions: [
                `${slugValidation.slug}-${Date.now().toString().slice(-4)}`,
                `${slugValidation.slug}-${Math.floor(Math.random() * 1000)}`,
                `${slugValidation.slug}-new`,
              ],
            });
          }
        }
      }
    }

    // Create portfolio
    const portfolio = await createPortfolio({
      studentId: user._id,
      slug: finalSlug,
      visibility: validation.portfolioData.visibility || "private",
      layout: validation.portfolioData.layout || "single-page",
      status: validation.portfolioData.status || "draft", // Default to draft
      theme: validation.portfolioData.theme || {
        name: "modern",
        colors: {},
        typography: {},
        spacing: "comfortable",
      },
      hero: validation.portfolioData.hero || {
        title: null,
        subtitle: null,
        image: null,
        ctaText: null,
        ctaLink: null,
      },
      sections: validation.portfolioData.sections || [],
      certificates: validation.portfolioData.certificates || [],
      animations: validation.portfolioData.animations || {
        enabled: false,
        type: "fade",
      },
      // Legacy support
      isPublic:
        validation.portfolioData.isPublic !== undefined
          ? validation.portfolioData.isPublic
          : validation.portfolioData.visibility === "public",
    });

    res.status(201).json({
      success: true,
      message: slugWasAutoGenerated
        ? `Portfolio created successfully. The slug "${slugValidation.slug}" was already taken, so we used "${finalSlug}" instead.`
        : "Portfolio created successfully",
      data: portfolio,
      ...(slugWasAutoGenerated && {
        originalSlug: slugValidation.slug,
        actualSlug: finalSlug,
        slugAutoGenerated: true,
      }),
    });
  } catch (error) {
    console.error("Create portfolio error:", error);

    // Handle MongoDB connection errors
    const isMongoConnectionError =
      error.name === "MongooseServerSelectionError" ||
      error.name === "MongoServerSelectionError" ||
      error.message?.includes("ECONNREFUSED") ||
      error.message?.includes("connect ECONNREFUSED") ||
      error.message?.includes("connection skipped");

    if (isMongoConnectionError) {
      return res.status(503).json({
        success: false,
        message:
          "Database service is currently unavailable. Please ensure MongoDB is running and try again.",
      });
    }

    // Handle duplicate key error (slug)
    if (error.code === 11000 || error.message.includes("duplicate")) {
      return res.status(400).json({
        success: false,
        message: "This slug is already taken. Please choose a different one.",
      });
    }

    res.status(500).json({
      success: false,
      message: "Error creating portfolio",
    });
  }
}
